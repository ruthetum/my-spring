# 스프링 고급편

## ThreadLocal
> v0, v1, v2 참고

쓰레드 로컬은 해당 쓰레드만 접근할 수 있는 특별한 저장소를 말한다. 쉽게 이야기해서 물건 보관 창구를 떠올리면 된다. 여러 사람이 같은 물건 보관 창구를 사용하더라도 창구 직원은 사용자를 인식해서 사용자별로 확실하게 물건을 구분해준다.
사용자A, 사용자B 모두 창구 직원을 통해서 물건을 보관하고, 꺼내지만 창구 지원이 사용자에 따라 보관한 물건을 구분해주는 것이다.

<img width="806" alt="스크린샷 2022-12-22 오후 9 46 50" src="https://user-images.githubusercontent.com/59307414/209137479-e17a0ddf-481b-44e1-bc62-8aa9ef949b51.png">

### ThreadLocal 사용법
- 값 저장: ThreadLocal.set(logicName)
- 값 조회: ThreadLocal.get()
- 값 제거: ThreadLocal.remove()

> 해당 쓰레드가 쓰레드 로컬을 모두 사용하고 나면 ThreadLocal.remove() 를 호출해서 쓰레드 로컬에
저장된 값을 제거해주어야 한다.

### ThreadLocal 주의사항
쓰레드 로컬의 값을 사용 후 제거하지 않고 그냥 두면 WAS(톰캣)처럼 쓰레드 풀을 사용하는 경우에 심각한 문제가 발생할 수 있다.

<img width="801" alt="스크린샷 2022-12-22 오후 11 52 29" src="https://user-images.githubusercontent.com/59307414/209160609-abafda2a-1d24-4f90-9fb6-c91ff756cf00.png">

<img width="804" alt="스크린샷 2022-12-22 오후 11 51 39" src="https://user-images.githubusercontent.com/59307414/209160468-5230daaa-d53d-4553-bc1f-ef36ddf2e5ed.png">

<img width="802" alt="스크린샷 2022-12-22 오후 11 53 04" src="https://user-images.githubusercontent.com/59307414/209160708-3aeff4bc-0db9-4280-8e66-49b64ed1db75.png">

WAS thread가 요청이 끝난 이후 반환되기 때문에 threadlocal에 값을 보관하고, 삭제해주지 않으면 해당 thread가 다른 사용자에게 할당되었을 때 잘못된 데이터를 전달할 수 있다.

따라서 사용했으면 remove를 해줘야 한다. remove는 필터 또는 인터셉터를 이용해서 요청에 대한 응답이 반환되는 시점에 적용한다.

## 템플릿 메서드
> v3, v4 참고

- https://github.com/ruthetum/study/tree/main/design-patterns/ch8-template-method

### 코드의 핵심 기능과 부가 기능
핵심 기능 vs 부가 기능

핵심 기능은 해당 객체가 제공하는 고유의 기능이다. 예를 들어서 orderService 의 핵심 기능은 주문 로직이다. 메서드 단위로 보면 orderService.orderItem() 의 핵심 기능은 주문 데이터를 저장하기 위해 리포지토리를 호출하는 orderRepository.save(itemId) 코드가 핵심 기능이다.

부가 기능은 핵심 기능을 보조하기 위해 제공되는 기능이다. 예를 들어서 로그 추적 로직, 트랜잭션 기능이 있다. 이러한 부가 기능은 단독으로 사용되지는 않고, 핵심 기능과 함께 사용된다. 예를 들어서 로그 추적 기능은 어떤 핵심 기능이 호출되었는지 로그를 남기기 위해 사용한다. 그러니까 핵심 기능을 보조하기 위해 존재한다.

부가 기능을 추가하다보면 핵심 기능 코드보다 부가 기능을 처리하기 위한 코드가 더 많아질 수 있다. 만약 클래스가 수백 개라면 어떻게 하겠는가? 유지보수 자체가 안 된다.

### 변하는 것과 변하지 않는 것을 분리
좋은 설계는 변하는 것과 변하지 않는 것을 분리하는 것이다.

핵심 기능 부분은 변하고, 로그 추적기를 사용하는 부분은 변하지 않는 부분이다. 이 둘을 분리해서 모듈화해야 한다.

템플릿 메서드 패턴(Template Method Pattern)은 이런 문제를 해결하는 디자인 패턴이다.

### 예제 코드 관련 설명
- OrderServiceV0 : 핵심 기능만 있다.
- OrderServiceV3 : 핵심 기능과 부가 기능이 함께 섞여 있다.
- OrderServiceV4 : 핵심 기능과 템플릿을 호출하는 코드가 섞여 있다.

> V4는 템플릿 메서드 패턴을 사용한 덕분에 핵심 기능에 좀 더 집중할 수 있게 되었다.

### 좋은 설계?
좋은 설계라는 것은 무엇일까? 수 많은 멋진 정의가 있겠지만, 진정한 좋은 설계는 바로 변경이 일어날 때 자연스럽게 드러난다.

지금까지 로그를 남기는 부분을 모아서 하나로 모듈화하고, 비즈니스 로직 부분을 분리했다. 여기서 만약 로그를 남기는 로직을 변경해야 한다고 생각해보자. 그래서 AbstractTemplate 코드를 변경해야 한다 가정해보자. 단순히 AbstractTemplate 코드만 변경하면 된다.
템플릿이 없는 V3 상태에서 로그를 남기는 로직을 변경해야 한다고 생각해보자. 이 경우 모든 클래스를 다 찾아서 고쳐야 한다. 클래스가 수백 개라면 생각만해도 끔찍하다.

### 단일 책임 원칙(SRP)
V4 는 단순히 템플릿 메서드 패턴을 적용해서 소스코드 몇줄을 줄인 것이 전부가 아니다.

로그를 남기는 부분에 단일 책임 원칙(SRP)을 지킨 것이다. 변경 지점을 하나로 모아서 변경에 쉽게 대처할 수 있는 구조를 만든 것이다.

## 전략 패턴
템플릿 메서드 패턴은 상속을 사용한다. 따라서 상속에서 오는 단점들을 그대로 안고간다. 특히 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제가 있다. 이것은 의존관계에 대한 문제이다. 자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않는다.

이번 장에서 지금까지 작성했던 코드를 떠올려보자. 자식 클래스를 작성할 때 부모 클래스의 기능을 사용한 것이 있었던가?

그럼에도 불구하고 템플릿 메서드 패턴을 위해 자식 클래스는 부모 클래스를 상속 받고 있다.

상속을 받는 다는 것은 특정 부모 클래스를 의존하고 있다는 것이다. 자식 클래스의 extends 다음에 바로 부모 클래스가 코드상에 지정되어 있다. 따라서 부모 클래스의 기능을 사용하든 사용하지 않든 간에 부모 클래스를 강하게 의존하게 된다. 여기서 강하게 의존한다는 뜻은 자식 클래스의 코드에 부모 클래스의 코드가 명확하게 적혀 있다는 뜻이다. UML에서 상속을 받으면 삼각형 화살표가 자식 -> 부모 를 향하고 있는 것은 이런 의존관계를 반영하는 것이다.

자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않는데, 부모 클래스를 알아야한다. 이것은 좋은 설계가 아니다. 그리고 이런 잘못된 의존관계 때문에 부모 클래스를 수정하면, 자식 클래스에도 영향을 줄 수 있다.

추가로 템플릿 메서드 패턴은 상속 구조를 사용하기 때문에, 별도의 클래스나 익명 내부 클래스를 만들어야 하는 부분도 복잡하다.
지금까지 설명한 이런 부분들을 더 깔끔하게 개선하려면 어떻게 해야할까?

템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴이 바로 전략 패턴 (Strategy Pattern)이다.

### 템플릿 메서드 vs 전략 패턴
> 템플릿 메서드는 상속을 기반으로 합니다. 자식 클래스들에서 알고리즘의 부분들을 확장하여 변경할 수 있도록 합니다.
> 반면 전략 패턴은 합성을 기반으로 합니다. 
> 당신은 객체 행동의 일부분들을 이러한 행동에 해당하는 다양한 전략들을 제공하여 변경할 수 있습니다.
> 템플릿 메서드는 클래스 수준에서 작동하므로 정적입니다. 전략 패턴은은 객체 수준에서 작동하므로 런타임에 행동들을 전환할 수 있도록 합니다.

## 템플릿 콜백 패턴
> v5 참고

스프링에서는 ContextV2 와 같은 방식의 전략 패턴을 템플릿 콜백 패턴이라 한다.

전략 패턴에서 Context 가 템플릿 역할을 하고, Strategy 부분이 콜백으로 넘어온다 생각하면 된다.

참고로 템플릿 콜백 패턴은 GOF 패턴은 아니고, 스프링 내부에서 이런 방식을 자주 사용하기 때문에, 스프링 안에서만 이렇게 부른다.

전략 패턴에서 템플릿과 콜백 부분이 강조된 패턴이라 생각하면 된다.

스프링에서는 JdbcTemplate , RestTemplate , TransactionTemplate , RedisTemplate 처럼 다양한 템플릿 콜백 패턴이 사용된다.

스프링에서 이름에 XxxTemplate 가 있다면 템플릿 콜백 패턴으로 만들어져 있다 생각하면 된다.

### 콜백 정의
> 프로그래밍에서 콜백(callback) 또는 콜애프터 함수(call-after function)는 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다.
> 콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고, 아니면 나중에 실행할 수도 있다.